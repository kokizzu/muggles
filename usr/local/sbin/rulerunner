#!/bin/sh
#set -x
#set -v

## dynamic rules for machines on lan decide what uplink they will use when leases file changes
## uses incrontab entry: /full/path/to/dnsmasq.leases IN_MODIFY,IN_NO_LOOP /etc/network/if-up.d/rulerunner $@
## which passes the path of dnsmasq.leases to $1

dleases_path=$1

logon=0
## logon=1 switches logging on, logon=0 switches it off

## end of configuration options


log ()
{ if [[ "${logon}" == "1" ]] ;
  then echo "$1" >> /var/log/muggles/rulerunner.log
 fi
## $1 here is not the argument to main, but the argument to log. Bash is funny that way.
}

log "############$(date):#################"
log "dnsmasq leases at: $dleases_path are now :"
while read line; do log "$line"; done < $dleases_path

log "rules:"
ip rule show | grep uplink | while read line; do log "$line"; done

log "------------------------------------------"
log "dnsmasq leases.1 is about to change from :"
while read line; do log "$line"; done < $dleases_path.1
log "dnsmasq leases.2 is about to change from :"
while read line; do log "$line"; done < $dleases_path.2
log "------------------------------------------"




NUMBER_OF_UPLINKS=$(ip link show | sed -e 's/[0-9][0-9]*: eth\([0-9][0-9]*\): <BROADCAST,MULTICAST,UP,LOWER_UP>.*/\1/' -e '$!{h;d;}' -e x)
lastinterface='eth'$NUMBER_OF_UPLINKS
## only works if interfaces used are eth...

NUMBER_OF_RULES=$(ip rule show | grep '^32[0-9]\{3\}' | grep 'lookup uplink' | wc -l)
## idea - automatically add rules in range 32000 - 32765. Can add rules manually to space < 32000)










## routing defined in interfaces per table gives: 
# roundrobin number? NUMBER_OF_UPLINKS=$(ip route show table all | grep "^default via .*table uplink[1-9][0-9]*" | wc -l)

## algorithm:

## whenever lease changes:
##   incron waits until this script ($0) is done (IN_NO_LOOP)
##   leasesfile may still change before we can read it (so be atomic, and copy canonical leasefile, and work with leasefile copies)
##   go through leases (in copies)
##       find lease line changes from last time with a diff
##        if it is only the lease time field that has changed, and the rest of the lease entry is the same, do no rule changes
##        else if an old ip address no longer exists, purge rules for that ip for all tables
##        else if a new ip address exists, ( purge rules for that ip for all tables first) and  add rule for a table (randomly, or rr style)
##   done

## with the above algorithm we cover these (exhaustive) cases:
## 1. a machine signs off its lease? Then lease line vanishes. Action: purge rules for that ip.
## 2. a machine disconnects without signing off? Then lease line stays until lease expiry time (ip stays), rules stay unchanged for that lease ip. Action: do nothing to rules.
##       If machine rejoins before lease expiry time, lease expiry time field (ip stays), rules stay unchanged for that lease ip. Action: do nothing to rules.
##       If machine stays disconnected at lease expiry time, lease line vanishes (ip vanishes). Action: purge rules for that lease ip.
## 3. a machine stays connected and refreshes its lease? Then lease expiry time field changes (ip stays). Action: do nothing to rules.
## 4. a new machine comes in? Then get a new lease line entry, new ip (guaranteed by dnsmasq to be non-conflicting for a genuinely new machine). Action: add rule for that ip.


filebasename=$(basename "$dleases_path")
if echo "$filebasename" | grep -q . ; then
      if [ -e $dleases_path.1 ] ; then cp $dleases_path.1 $dleases_path.2 ; fi
      if [ -e $dleases_path ] ; then cut -f2-4 -d" " $dleases_path | sort > $dleases_path.1 ; fi
fi
## atomic, and secure
## get rid of epoch time field for algorithm purposes


function uplink_roundrobin_number
{
## defined in /etc/network/interfaces and /etc/iproute2/rt_tables  
uplink_rr=$(( NUMBER_OF_RULES%NUMBER_OF_UPLINKS + 1 ))
echo $uplink_rr
}
### important to do - must we remove rules when machine leaves so we have a correct number of rules so rr works? ( do removal with incron )
## FIXME

function uplink_random_uplink_number
{
uplink_rand=$(( RANDOM%NUMBER_OF_UPLINKS +1 ))
echo $uplink_rand
}

add_iplist=$(diff $dleases_path.1 $dleases_path.2 | grep '^<' | cut -f3 -d" ")
if echo "$add_iplist" | grep -q . ; then
  for i in $add_iplist; do
    while ( ip rule del from $i 2>/dev/null ) ; do
      echo "removing new ip $i from rules"
      log "removing new ip $i from rules"
    done
    ## get rid of *all* old rules on that ip just in case they exist
    ip rule add from $i table uplink$(uplink_random_uplink_number) ; echo "added new ip $i to rules" ; log "added new ip $i to rules"
  done
fi


remove_iplist=$(diff $dleases_path.1 $dleases_path.2 | grep '^>' | cut -f3 -d" ")
if echo "$remove_iplist" | grep -q . ; then
  for i in $remove_iplist; do
    while ( ip rule del from $i 2>/dev/null ) ; do
      echo "removing old ip $i from rules"
      log "removing old ip $i from rules"
    done
    ## get rid of *all* old rules on that ip just in case they exist
  done
fi




## manual rules section
## what if we don't like the automatic rule above for uplink for a user? Then remove and reinsert. Eg:
## if we want to force alan to uplink1 with priority 700 (let's keep non-roundrobin users below 1000, above 700)

function manual_rule_insert {
  machinename=$1; uplink=$2 ; priority=$3
  ip_machine=$(cut -f3,4 -d" " $dleases_path | grep '$1$' | cut -f1 -d" ")

  if [ ! -z "$ip_machine" ] ; then
    while ( ip rule del from $ip_machine 2>/dev/null ) ; do
      echo "removing $ip_machine ($machinename) from rules"
      log "removing $ip_machine ($machinename) from rules"
    done

    ip rule add from $ip_machine table $uplink prio $priority
    echo "adding rule from $ip_machine table $uplink prio $priority"
    log "adding rule from $ip_machine table $uplink prio $priority"
  fi
}


## machinename=$1; uplink=$2 ; priority=$3
#manual_rule_insert "alan" "uplink1" "700"
## uncomment above line to assign rule so that machinename uses uplink1 with priority 700
## and add other lines according to taste.

##
## end of manual rules section

ip rule show
ip route flush cache

echo "done rules and flushing cache"


log "------------------------------------------"
log "dnsmasq leases.1 is now :"
while read line; do log "$line"; done < $dleases_path.1
log "dnsmasq leases.2 is now :"
while read line; do log "$line"; done < $dleases_path.2
log "------------------------------------------"
log "rules:"
ip rule show | grep uplink | while read line; do log "$line"; done
